<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zpauly&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-29T08:54:09.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zpauly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Instant Run学习的思考--热修复</title>
    <link href="http://yoursite.com/2017/03/26/Instant-Run%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83-%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    <id>http://yoursite.com/2017/03/26/Instant-Run学习的思考-热修复/</id>
    <published>2017-03-26T13:31:57.000Z</published>
    <updated>2017-03-29T08:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在记录自己对Instant Run的学习之前，先讲一下自己会去看Instant Run的原因吧。前一段时间，美团的Robust热修复框架开源成功在今年的Android届吸引了一大波关注，当然，我也去<a href="https://github.com/Meituan-Dianping/Robust" target="_blank" rel="external">Robust的开源地址</a>和<a href="http://tech.meituan.com/android_robust.html" target="_blank" rel="external">美团官方技术博客</a>上看了一波。在其中，设计者提到了灵感来源于Google的Instant Run方案，这也成功勾起了我的兴趣。于是便将Instant Run的源码clone了下来对其中重要的部分好好学习了一番，果然还是颇有收获。</p>
<hr>
<h2 id="Instant-Run安装原理"><a href="#Instant-Run安装原理" class="headerlink" title="Instant Run安装原理"></a>Instant Run安装原理</h2><p>Instant Run是Google在2016年的Google I/O大会上在退出Android Studio2.2版本的同时推出的其自带的一套快速部署机制，这些大家都知道了。但是它在我们写完代码按下部署按钮之后到底干了些什么呢？<br>在我看来，Instant Run与其说是一个运行机制，不如说就是一个Android应用程序。通过对经过Instant Run安装到手机中的应用进行反编译，我们不难发现其实安装在我们手机里的实际上并不是我们自己写的应用。实际上Instant Run是一个宿主程序，将我们自己写的程序作为资源加载进来通过对资源的解析最终将我们的程序显示出来。仔细想想，这不就是一个“双开”程序吗？？？当然，确实如此，不过这里我先不谈这个，以此为引子来讲一下它所带来的对于热修复的一个新的提示——快速部署。</p>
<hr>
<h2 id="简单的加载过程"><a href="#简单的加载过程" class="headerlink" title="简单的加载过程"></a>简单的加载过程</h2><p>对于加载过程的简单介绍当然是必不可少的，毕竟想要去了解Instant Run的部署功能还是要先知道它是从哪里入手的才行。<br>在Instant Run的宿主程序中，存在一个永远不变的主<code>Application</code>——<code>BootstrapApplication</code>，一切由它开始。作为一个<code>Application</code>，最重要的自然是这么两个方法——<code>onCreate()</code>和<code>attachBaseContext()</code>。我们就先从一个应用的开始<code>attachBaseContext()</code>开始看起。</p>
<blockquote>
<p>BootstrapApplication</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!AppInfo.usingApkSplits) &#123;</div><div class="line">        String apkFile = context.getApplicationInfo().sourceDir;<span class="comment">//获取资源apk的路径</span></div><div class="line">        <span class="keyword">long</span> apkModified = apkFile != <span class="keyword">null</span> ? <span class="keyword">new</span> File(apkFile).lastModified() : <span class="number">0L</span>;</div><div class="line">        createResources(apkModified);<span class="comment">//判断资源是否发生变化</span></div><div class="line">        setupClassLoaders(context, context.getCacheDir().getPath(), apkModified);<span class="comment">//针对资源apk创建其的classloader</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createRealApplication();<span class="comment">//通过反射获取资源apk中的真正要加载的应用的Application，并将其赋值给realApplication</span></div><div class="line">        </div><div class="line">    <span class="keyword">super</span>.attachBaseContext(context);</div><div class="line"></div><div class="line">    <span class="comment">//如果能够获取到realApplicaion则通过反射去调用其中的attachBaseContext()方法</span></div><div class="line">    <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method attachBaseContext =</div><div class="line">                        ContextWrapper.class.getDeclaredMethod(<span class="string">"attachBaseContext"</span>, Context.class);</div><div class="line">            attachBaseContext.setAccessible(<span class="keyword">true</span>);</div><div class="line">            attachBaseContext.invoke(realApplication, context);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们看到这里所做的只是一些反射调用来做加载资源应用的一些准备工作，真正的部署工作也就落在了之后的<code>onCreate()</code>方法中。</p>
<blockquote>
<p>BootstrapApplication</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//将资源apk与本应用合并</span></div><div class="line">   <span class="keyword">if</span> (!AppInfo.usingApkSplits) &#123;</div><div class="line">       MonkeyPatcher.monkeyPatchApplication(</div><div class="line">               BootstrapApplication.<span class="keyword">this</span>, BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">               realApplication, externalResourcePath);</div><div class="line">       MonkeyPatcher.monkeyPatchExistingResources(BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">               externalResourcePath, <span class="keyword">null</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       MonkeyPatcher.monkeyPatchApplication(</div><div class="line">               BootstrapApplication.<span class="keyword">this</span>, BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">               realApplication, <span class="keyword">null</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">super</span>.onCreate();</div><div class="line"></div><div class="line">   <span class="comment">//启动Server，这个Server就是真正部署操作的执行者</span></div><div class="line">   <span class="keyword">if</span> (AppInfo.applicationId != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">boolean</span> foundPackage = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">int</span> pid = Process.myPid();</div><div class="line">           ActivityManager manager = (ActivityManager) getSystemService(</div><div class="line">                   Context.ACTIVITY_SERVICE);</div><div class="line">           List&lt;RunningAppProcessInfo&gt; processes = manager.getRunningAppProcesses();</div><div class="line"></div><div class="line">           <span class="keyword">boolean</span> startServer;</div><div class="line">           <span class="keyword">if</span> (processes != <span class="keyword">null</span> &amp;&amp; processes.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">               startServer = <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">for</span> (RunningAppProcessInfo processInfo : processes) &#123;</div><div class="line">                   <span class="keyword">if</span> (AppInfo.applicationId.equals(processInfo.processName)) &#123;</div><div class="line">                       foundPackage = <span class="keyword">true</span>;</div><div class="line">                       <span class="keyword">if</span> (processInfo.pid == pid) &#123;</div><div class="line">                           startServer = <span class="keyword">true</span>;</div><div class="line">                           <span class="keyword">break</span>;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (!startServer &amp;&amp; !foundPackage) &#123;</div><div class="line">                   startServer = <span class="keyword">true</span>;</div><div class="line">                   <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">                       Log.v(LOG_TAG, <span class="string">"Multiprocess but didn't find process with package: "</span></div><div class="line">                               + <span class="string">"starting server anyway"</span>);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               startServer = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (startServer) &#123;</div><div class="line">               Server.create(AppInfo.applicationId, BootstrapApplication.<span class="keyword">this</span>);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">           <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">               Log.v(LOG_TAG, <span class="string">"Failed during multi process check"</span>, t);</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//Server创建并运行</span></div><div class="line">           Server.create(AppInfo.applicationId, BootstrapApplication.<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用realApplicaion的onCreate()我们的应用正式运行</span></div><div class="line">   <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">       realApplication.onCreate();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里分成三部分，资源部署-&gt;开启Server-&gt;realAppication正式启动。第三步不用多说，这里简单介绍一下前两步。第一步所做的事情就是将我们自己所写的实际上的应用加载进这个宿主程序中来，这就是我们所常常会听到的应用插件化中的一个概念“双开”，这里先不多说来看看第二步。从Server这个类的名字我们就可以猜到它与我们实际运行的程序实际上是一个C/S的关系（Google好像很喜欢搞C/S结构的东西，Android源码中就到处都是C/S架构），那它的作用是什么呢？？？</p>
<blockquote>
<p>Server</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//静态函数create()负责调用Server的构造方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(@NonNull String packageName, @NonNull Application application)</span> </span>&#123;</div><div class="line">   <span class="keyword">new</span> Server(packageName, application);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Server</span><span class="params">(@NonNull String packageName, @NonNull Application application)</span> </span>&#123;</div><div class="line">   mApplication = application;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//创建一个Server的Socket，Socket所做的工作便是对我们的IDE监听</span></div><div class="line">       mServerSocket = <span class="keyword">new</span> LocalServerSocket(packageName);</div><div class="line">       <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">           Log.v(LOG_TAG, <span class="string">"Starting server socket listening for package "</span> + packageName</div><div class="line">                   + <span class="string">" on "</span> + mServerSocket.getLocalSocketAddress());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">       Log.e(LOG_TAG, <span class="string">"IO Error creating local socket at "</span> + packageName, e);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//开启Server</span></div><div class="line">   startServer();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">       Log.v(LOG_TAG, <span class="string">"Started server for package "</span> + packageName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//可以看到这里为Server单独开启了一个线程</span></div><div class="line">       Thread socketServerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SocketServerThread());</div><div class="line">       socketServerThread.start();</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.ERROR)) &#123;</div><div class="line">           Log.e(LOG_TAG, <span class="string">"Fatal error starting Instant Run server"</span>, e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到这里开起了一个线程并创建了一个Socket，该Socket所做的事情是对我们的IDE进行监听，当我们需要将我们所写的代码需要被部署的时候Server端便会做点什么。那么我们来看看这个线程都做了些什么。</p>
<blockquote>
<p>Server.SocketServerThread</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       ......</div><div class="line"></div><div class="line">        <span class="comment">//这是一个一直循环着的线程</span></div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               LocalServerSocket serverSocket = mServerSocket;</div><div class="line">               <span class="keyword">if</span> (serverSocket == <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">break</span>; <span class="comment">// stopped?</span></div><div class="line">               &#125;</div><div class="line">               <span class="comment">//调用Socket的accept()函数开始监听</span></div><div class="line">               LocalSocket socket = serverSocket.accept();</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">                   Log.v(LOG_TAG, <span class="string">"Received connection from IDE: spawning connection thread"</span>);</div><div class="line">               &#125;</div><div class="line">                </div><div class="line">                <span class="comment">//当Socket监听到内容的时候，又再次开启一个线程对此进行相应的操作</span></div><div class="line">               SocketServerReplyThread socketServerReplyThread = <span class="keyword">new</span> SocketServerReplyThread(</div><div class="line">                       socket);</div><div class="line">               socketServerReplyThread.run();</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (sWrongTokenCount &gt; <span class="number">50</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">                       Log.v(LOG_TAG, <span class="string">"Stopping server: too many wrong token connections"</span>);</div><div class="line">                   &#125;</div><div class="line">                   mServerSocket.close();</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">               <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">                   Log.v(LOG_TAG, <span class="string">"Fatal error accepting connection on local socket"</span>, e);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们发现，当Socket所在的线程监听到我们的程序有改变的内容需要进行部署的时候，便会再次开启一个线程，莫非这个线程所作的事情就是我们所想要知道的更新部署操作？？？</p>
<blockquote>
<p>Server.SocketServerReplyThread</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerReplyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> LocalSocket mSocket;</div><div class="line"></div><div class="line">   SocketServerReplyThread(LocalSocket socket) &#123;</div><div class="line">       mSocket = socket;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获取Socket的输入输出流</span></div><div class="line">           DataInputStream input = <span class="keyword">new</span> DataInputStream(mSocket.getInputStream());</div><div class="line">           DataOutputStream output = <span class="keyword">new</span> DataOutputStream(mSocket.getOutputStream());</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">//执行handle函数</span></div><div class="line">               handle(input, output);</div><div class="line">           &#125; <span class="keyword">finally</span> &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   input.close();</div><div class="line">               &#125; <span class="keyword">catch</span> (IOException ignore) &#123;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   output.close();</div><div class="line">               &#125; <span class="keyword">catch</span> (IOException ignore) &#123;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">           <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">               Log.v(LOG_TAG, <span class="string">"Fatal error receiving messages"</span>, e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们查看到了一个<code>handle()</code>方法，该方法似乎将会对我们的Socket所监听到的内容进行处理。</p>
<blockquote>
<p>Server.SocketServerReplyThread</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(DataInputStream input, DataOutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  ......</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">int</span> message = input.readInt();<span class="comment">//从Socket中获取信息</span></div><div class="line">      <span class="keyword">switch</span> (message) &#123;</div><div class="line">          ......</div><div class="line">          <span class="comment">//当信息为MESSAGE_PATCHES时，进行真正的更新代码部署操作</span></div><div class="line">          <span class="keyword">case</span> MESSAGE_PATCHES: &#123;</div><div class="line">              <span class="keyword">if</span> (!authenticate(input)) &#123;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              List&lt;ApplicationPatch&gt; changes = ApplicationPatch.read(input);</div><div class="line">              <span class="keyword">if</span> (changes == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">continue</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">boolean</span> hasResources = hasResources(changes);</div><div class="line">              <span class="keyword">int</span> updateMode = input.readInt();</div><div class="line">              <span class="comment">//进行更新代码部署操作</span></div><div class="line">              updateMode = handlePatches(changes, hasResources, updateMode);</div><div class="line"></div><div class="line">              <span class="keyword">boolean</span> showToast = input.readBoolean();</div><div class="line"></div><div class="line">              output.writeBoolean(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">              restart(updateMode, hasResources, showToast);</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          ......</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法中，Server从Socket中获取到了输入信息message，对于其余的输入信息我们不多做研究，我们主要关注的就是当输入信息为<code>MESSAGE_PATCHES</code>时所要做的事情，这里我们发现了<code>handlePatches()</code>函数，从名字里我们就可以看出来我们终于找到了部署操作的入口。</p>
<p>小结：在开始分析部署功能之前，我们对Instant Run运行过程做一个简单的小结。Instant Run是一个宿主程序，我们自己所写的程序便是运行在这个宿主程序之中的，而这个宿主程序中存在着一个C/S架构，Server端负责时刻监视我们的所需运行的程序，如果程序代码发生了改变，便会立刻将改变的内容进行部署。</p>
<hr>
<h2 id="部署功能解析"><a href="#部署功能解析" class="headerlink" title="部署功能解析"></a>部署功能解析</h2><p>经过我们对Instant Run运行过程的分析，我们总算是找到了部署功能的入口，我们来看看它都是怎么做的。</p>
<blockquote>
<p>Server</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handlePatches</span><span class="params">(@NonNull List&lt;ApplicationPatch&gt; changes, <span class="keyword">boolean</span> hasResources,</span></span></div><div class="line">       <span class="keyword">int</span> updateMode) &#123;</div><div class="line">   <span class="keyword">if</span> (hasResources) &#123;</div><div class="line">       FileManager.startUpdate();</div><div class="line">   &#125;</div><div class="line">    <span class="comment">//对ApplicationPatch列表进行遍历</span></div><div class="line">   <span class="keyword">for</span> (ApplicationPatch change : changes) &#123;</div><div class="line">       String path = change.getPath();</div><div class="line">       <span class="keyword">if</span> (path.endsWith(CLASSES_DEX_SUFFIX)) &#123;</div><div class="line">            <span class="comment">//当patch后“.dex”时进行冷部署</span></div><div class="line">           handleColdSwapPatch(change);</div><div class="line"></div><div class="line">           <span class="keyword">boolean</span> canHotSwap = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">for</span> (ApplicationPatch c : changes) &#123;</div><div class="line">               <span class="keyword">if</span> (c.getPath().equals(RELOAD_DEX_FILE_NAME)) &#123;</div><div class="line">                   canHotSwap = <span class="keyword">true</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (!canHotSwap) &#123;</div><div class="line">               updateMode = UPDATE_MODE_COLD_SWAP;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(RELOAD_DEX_FILE_NAME)) &#123;</div><div class="line">          <span class="comment">//当patch后缀为”classes.dex.3“时进行热部署</span></div><div class="line">           updateMode = handleHotSwapPatch(updateMode, change);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isResourcePath(path)) &#123;</div><div class="line">           <span class="comment">//其余情况进行温部署</span></div><div class="line">           updateMode = handleResourcePatch(updateMode, change, path);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (hasResources) &#123;</div><div class="line">       FileManager.finishUpdate(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> updateMode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具体分析之前，先了解一下冷、热、温部署都代表了什么：<br><img src="/2017/03/26/Instant-Run学习的思考-热修复/部署流程.png" alt="部署流程.png" title=""></p>
<ul>
<li>热部署：方法内的简单修改，无需重启app和<code>Activity</code>。</li>
<li>冷部署：继承关系的改变或方法的签名变化等情况，应用需要重启。 </li>
<li>温部署：资源的修改等情况，app无需重启，但是<code>Activity</code>需要重启。</li>
</ul>
<p>接下来我们对着三种部署方式进行分析：</p>
<h3 id="热部署过程"><a href="#热部署过程" class="headerlink" title="热部署过程"></a>热部署过程</h3><blockquote>
<p>Server</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handleHotSwapPatch</span><span class="params">(<span class="keyword">int</span> updateMode, @NonNull ApplicationPatch patch)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       String dexFile = FileManager.writeTempDexFile(patch.getBytes());</div><div class="line">       <span class="keyword">if</span> (dexFile == <span class="keyword">null</span>) &#123;</div><div class="line">           Log.e(LOG_TAG, <span class="string">"No file to write the code to"</span>);</div><div class="line">           <span class="keyword">return</span> updateMode;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">           Log.v(LOG_TAG, <span class="string">"Reading live code from "</span> + dexFile);</div><div class="line">       &#125;</div><div class="line">       String nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();</div><div class="line">       <span class="comment">//创建DexClassLoader</span></div><div class="line">       DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(dexFile,</div><div class="line">               mApplication.getCacheDir().getPath(), nativeLibraryPath,</div><div class="line">               getClass().getClassLoader());</div><div class="line"></div><div class="line">       <span class="comment">//反射获取AppPatchesLoaderImpl类aClass</span></div><div class="line">       Class&lt;?&gt; aClass = Class.forName(</div><div class="line">               <span class="string">"com.android.tools.fd.runtime.AppPatchesLoaderImpl"</span>, <span class="keyword">true</span>, dexClassLoader);</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//根据aClass反射创建实例loader</span></div><div class="line">           PatchesLoader loader = (PatchesLoader) aClass.newInstance();</div><div class="line">           <span class="comment">//反射执行loader的实例方法getPatchedClasses()</span></div><div class="line">           String[] getPatchedClasses = (String[]) aClass</div><div class="line">                   .getDeclaredMethod(<span class="string">"getPatchedClasses"</span>).invoke(loader);</div><div class="line">            <span class="comment">//执行loader的实例方法loader()</span></div><div class="line">           <span class="keyword">if</span> (!loader.load()) &#123;</div><div class="line">               updateMode = UPDATE_MODE_COLD_SWAP;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">           updateMode = UPDATE_MODE_COLD_SWAP;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       updateMode = UPDATE_MODE_COLD_SWAP;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> updateMode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是不是看得一头雾水？这里涉及的主要就是反射调用，这里我们基本可以分析出来内容的就是去获取一个<code>AppPatchesLoaderImpl</code>类的实例，这个类是<code>PatchesLoader</code>类的子类，然后反射调用了该实例等<code>getPatchesClases()</code>方法。<br>不过我们发现，在Instant Run框架中并不存在<code>AppPatchesLoaderImpl</code>类，不过我们可以找到的是<code>PatchesLoader</code>，这是一个接口。</p>
<blockquote>
<p>PatchesLoader</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PatchesLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们发现的是一个<code>load()</code>方法，但是并没有<code>getPatchedClasses()</code>方法啊，因此我们可以知道的是<code>getPatchedClasses()</code>方法存在于<code>PatchesLoader</code>的实现类<code>AppPatchesLoaderImpl</code>中。<br>我们想要找到<code>AppPatchesLoaderImpl</code>类还需要进入到实际运行在我们手机中的程序里找。<br>这里我构建了一个简单的应用，它的功能就是简单的打出嗝Toast。我们在手机中的/data/data/com.zpauly.simple路径下会找到我们的应用。这里注意，由于Instant Run实际上在我们手机上部署的是一个宿主应用，因此在/data/app/{applicationId}路径下的并不是我们自己的应用，而是一个宿主程序。<br>在/data/data/com.zpauly.simple/files/instant-run/dex-temp路径下面，我们找到了一个dex文件，这就是我们每次部署的时候所会加载的dex补丁包。我们将这个补丁包反编译下来就能看到这样的东西<br><img src="/2017/03/26/Instant-Run学习的思考-热修复/pic0.png" alt="pic0.png" title=""><br>我们发现了我们所需要的<code>AppPatchesLoaderImpl</code>类！！！那我们就来看看里面都是什么东西吧。</p>
<blockquote>
<p>AppPatchesLoaderImpl</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.android.tools.fd.runtime;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPatchesLoaderImpl</span></span></div><div class="line">  <span class="keyword">extends</span> <span class="title">AbstractPatchesLoaderImpl</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BUILD_ID = <span class="number">1490698846571L</span>;</div><div class="line">  <span class="comment">//获取需要进行修改的类的完整类名</span></div><div class="line">  <span class="keyword">public</span> String[] getPatchedClasses()</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"com.zpauly.simple.MainActivity"</span> &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然我们所需要的<code>getPatchedClasses()</code>方法在这里，这里所返回的便是我们的需要进行修改的Class的完整类名。<br>虽然找到了<code>getPatchedClasses()</code>方法，但是并没有找到<code>loader()</code>方法。我们看到这里的<code>AppPatchesLoaderImpl</code>继承的是<code>AbstractPatchedLoaderImpl</code>，并非直接实现<code>PatchesLoader</code>，那么<code>loader()</code>方法等实现估计就是在这里了，我们看看<code>AbstractPatchedLoaderImpl</code>。</p>
<blockquote>
<p>AbstractPatchedLoaderImpl</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPatchesLoaderImpl</span> <span class="keyword">implements</span> <span class="title">PatchesLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] getPatchedClasses();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//遍历所有需要改变的类名，下面以com.zpauly.MainActivity为例</span></div><div class="line">            <span class="keyword">for</span> (String className : getPatchedClasses()) &#123;</div><div class="line">                ClassLoader cl = getClass().getClassLoader();</div><div class="line">                Class&lt;?&gt; aClass = cl.loadClass(className + <span class="string">"$override"</span>);<span class="comment">//获取名为com.zpauly.MainActivity$override的类</span></div><div class="line">                Object o = aClass.newInstance();<span class="comment">//反射创建它的实例</span></div><div class="line">                Class&lt;?&gt; originalClass = cl.loadClass(className);<span class="comment">//反射获取com.zpauly.MainActivity</span></div><div class="line">                Field changeField = originalClass.getDeclaredField(<span class="string">"$change"</span>);<span class="comment">//反射获取com.zpauly.MainActivity中的静态变量$change</span></div><div class="line">changeField.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">                Object previous = changeField.get(<span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                    Field isObsolete = previous.getClass().getDeclaredField(<span class="string">"$obsolete"</span>);</div><div class="line">                    <span class="keyword">if</span> (isObsolete != <span class="keyword">null</span>) &#123;</div><div class="line">                        isObsolete.set(<span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将创建的com.zpauly.MainActivity$override类的实例赋给$change</span></div><div class="line">                changeField.set(<span class="keyword">null</span>, o);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.log(Level.SEVERE, String.format(<span class="string">"Exception while patching %s"</span>, <span class="string">"foo.bar"</span>), e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么一大堆反射是不是看得云里雾里。没关系，我这就来讲一下为什么这么做。<br>其实在我们的程序进行gradle编译的过程中，Instant Run会向我们的程序注入大量的代码，然后我们的<code>MainActivity</code>就变成了下面这副模样。</p>
<blockquote>
<p>MainActivity</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IncrementalChange $change = <span class="keyword">null</span>;    </div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    MainActivity(Object[] paramArrayOfObject,</div><div class="line">    		InstantReloadException paramInstantReloadException) &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle paramBundle)</span> </span>&#123;</div><div class="line">    	IncrementalChange localIncrementalChange = $change;</div><div class="line">    	<span class="keyword">if</span> (localIncrementalChange != <span class="keyword">null</span>) &#123;</div><div class="line">    		localIncrementalChange.access$dispatch(</div><div class="line">    				<span class="string">"onCreate.(Landroid/os/Bundle;)V"</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>,</div><div class="line">    						paramBundle &#125;);</div><div class="line">    		<span class="keyword">return</span>;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">super</span>.onCreate(paramBundle);</div><div class="line">    	setContentView(<span class="number">2130968603</span>);</div><div class="line">    	Toast.makeText(<span class="keyword">this</span>, <span class="string">"show toast"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，在程序编译期间，Instant Run会为每一个类中的每一个方法中的最开始添加上一段代码，这段代码会对<code>$change</code>变量进行判断，如果它不为null，那么我们自己的代码就不将会去执行，而是执行<code>access$diapatch()</code>方法。<br>所以我们就知道了，<code>AbstractPatchedLoaderImpl</code>中的<code>load()</code>方法的作用就是去对所需进行改变的类中的<code>$change</code>的静态变量进行赋值，这样就能够起到一种拦截的作用，我们原本的代码就将不会执行而会执行<code>$change</code>中的<code>access$dispatch()</code>方法。<br>在上面的<code>load()</code>方法中，赋给变量<code>$change</code>的内容是一个类型为<code>MainActivity$override</code>的实例。我们再回到我们反编译的内容中看看这个类都做了什么。</p>
<blockquote>
<p>MainActivity$override</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$<span class="title">override</span></span></div><div class="line">  <span class="keyword">implements</span> <span class="title">IncrementalChange</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object init$args(MainActivity[] paramArrayOfMainActivity, Object[] paramArrayOfObject)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123; &#123; paramArrayOfMainActivity, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;, <span class="string">"android/support/v7/app/AppCompatActivity.()V"</span> &#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> init$body(MainActivity paramMainActivity, Object[] paramArrayOfObject) &#123;&#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(MainActivity paramMainActivity, Bundle paramBundle)</span></span></div><div class="line">  &#123;</div><div class="line">    MainActivity.access$<span class="keyword">super</span>(paramMainActivity, <span class="string">"onCreate.(Landroid/os/Bundle;)V"</span>, <span class="keyword">new</span> Object[] &#123; paramBundle &#125;);</div><div class="line">    paramMainActivity.setContentView(<span class="number">2130968603</span>);</div><div class="line">    Toast.makeText(paramMainActivity, <span class="string">"show toast"</span>, <span class="number">0</span>).show();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> Object access$dispatch(String paramString, Object... paramVarArgs)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">switch</span> (paramString.hashCode())</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">default</span>: </div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InstantReloadException(String.format(<span class="string">"String switch could not find '%s' with hashcode %s in %s"</span>, <span class="keyword">new</span> Object[] &#123; paramString, Integer.valueOf(paramString.hashCode()), <span class="string">"com/zpauly/simple/MainActivity"</span> &#125;));</div><div class="line">    <span class="keyword">case</span> -<span class="number">641568046</span>: </div><div class="line">      onCreate((MainActivity)paramVarArgs[<span class="number">0</span>], (Bundle)paramVarArgs[<span class="number">1</span>]);</div><div class="line">      paramString = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> paramString;</div><div class="line">      paramString = init$args((MainActivity[])paramVarArgs[<span class="number">0</span>], (Object[])paramVarArgs[<span class="number">1</span>]);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">      init$body((MainActivity)paramVarArgs[<span class="number">0</span>], (Object[])paramVarArgs[<span class="number">1</span>]);</div><div class="line">      paramString = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到<code>MainActivity$override</code>是<code>IncrementalChange</code>类型的实现类，在它的<code>access$dispatch()</code>方法中，它通过传入的方法名来选择执行的内容。当我们的<code>MainActivity</code>执行了该方法并传入了<code>onCreate()</code>方法名作时，<code>MainActivity$override</code>便会执行它自己的<code>onCreate()</code>方法来替代<code>MainActivity</code>中原本的方法。<br>小结：这么一来，关于热部署的内容就很明了了，它所做的事情就是通过向我们所写的代码中的每一个方法的最开始注入一段拦截代码，这段拦截代码会对一个<code>$change</code>变量进行判断，当我们的程序发生了改变需要部署时，Instant Run便会针对我们所需要改变的类生成补丁类，然后通过反射将我们的补丁类的实例赋给这个<code>$change</code>变量，然后这段拦截代码便会成功拦截下原先的代码转而执行补丁类中的代码。</p>
<h3 id="冷部署"><a href="#冷部署" class="headerlink" title="冷部署"></a>冷部署</h3><p>看完了热部署，我们来看看冷部署。首先进入<code>handleColdSwapPatch()</code>方法。</p>
<blockquote>
<p>Server</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleColdSwapPatch</span><span class="params">(@NonNull ApplicationPatch patch)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (patch.path.startsWith(Paths.DEX_SLICE_PREFIX)) &#123;</div><div class="line">      <span class="comment">//调用FileManager.writeDexShard()函数将会将dex文件写入临时目录</span></div><div class="line">      File file = FileManager.writeDexShard(patch.getBytes(), patch.path);</div><div class="line">      <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">          Log.v(LOG_TAG, <span class="string">"Received dex shard "</span> + file);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会将我们所写的最新的程序等dex文件写入临时文件，然后当SocketServerReplyThread线程发现当前使用的是冷部署处理的时候，便会重启，在重启后宿主程序又将重新加载tmp目录中的dex文件，这样我们新的程序所编译生成的dex包便会被执行。</p>
<h3 id="温部署"><a href="#温部署" class="headerlink" title="温部署"></a>温部署</h3><p>接下来再看看温部署。</p>
<blockquote>
<p>Server</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handleResourcePatch</span><span class="params">(<span class="keyword">int</span> updateMode, @NonNull ApplicationPatch patch,</span></span></div><div class="line">       @NonNull String path) &#123;</div><div class="line">   <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</div><div class="line">       Log.v(LOG_TAG, <span class="string">"Received resource changes ("</span> + path + <span class="string">")"</span>);</div><div class="line">   &#125;</div><div class="line">   FileManager.writeAaptResources(path, patch.getBytes());</div><div class="line">   updateMode = Math.max(updateMode, UPDATE_MODE_WARM_SWAP);</div><div class="line">   <span class="keyword">return</span> updateMode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>温部署我们上面提到过，就是当资源发生改变的时候所进行的部署方式。因此，这里的处理方式和上面的冷部署十分相似，就是将资源文件写入临时目录当中去，然后等待<code>Activity</code>的重启。至于温部署和冷部署是如何将文件进行合并的，那都是插件化相关的内容，下回再谈。</p>
<hr>
<h2 id="关于热部署再说一点"><a href="#关于热部署再说一点" class="headerlink" title="关于热部署再说一点"></a>关于热部署再说一点</h2><p>关于热部署，其实Instant Run所做的事情就是灵活地运用反射在程序运行期间去动态的改变程序的运行轨迹。在这里要多说一点的是除了<code>access$dispatch()</code>以外，Instant Run还在编译期注入了一个<code>access$super()</code>方法。我们知道，在java的反射机制中是没有提供任何方式来调用父类方法的因此Instant Run才会注入这么一个方法，来提供父类方法的调用。当然，也并非只有这种方式才行，在美团的Robust框架中，就使用了修改指令集的方式来做到这点，这种方式的好处就在于免去了增加方法数的弊端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里我对自己从Instant Run中所学到的关于热更新的思想做了一个简单的记录，下面我还会对其中的插件化思想做一个学习和记录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在记录自己对Instant Run的学习之前，先讲一下自己会去看Instant Run的原因吧。前一段时间，美团的Robust热修复框架开源成功在今年的Android届吸引了一大波关注，当然，我也去&lt;a href=&quot;https://github.com/Meituan-Di
    
    </summary>
    
      <category term="拆轮子系列" scheme="http://yoursite.com/categories/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Instant Run" scheme="http://yoursite.com/tags/Instant-Run/"/>
    
      <category term="热修复" scheme="http://yoursite.com/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化方法总结</title>
    <link href="http://yoursite.com/2017/03/10/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/03/10/Android性能优化方法总结/</id>
    <published>2017-03-10T07:06:34.000Z</published>
    <updated>2017-03-10T09:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间好好总结了一下Android性能优化的内容。对于其中的各种原理和各种工具的使用方法这里就不多做介绍了，相关资料确实相当多。下面就是我对于常见的性能优化方法的一个简单的总结。</p>
<h1 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h1><ul>
<li>尽量不要在循环中创建很多临时变量。</li>
<li>可以引入大型的循环拆分、分段或者按需执行。</li>
<li>引入SDK库和调用新的系统API时需要考虑成本。</li>
<li>注意避免内存泄漏，这里推荐QZONE团队的一篇<a href="http://mp.weixin.qq.com/s/fGOZYonnLONKYFukKqRVSQ?scene=25%23wechat_redirect" target="_blank" rel="external">文章</a></li>
<li>通过仔细统计和调整dex文件的顺序后，往往也能优化很多内存空间。</li>
</ul>
<h1 id="耗电量优化原则"><a href="#耗电量优化原则" class="headerlink" title="耗电量优化原则"></a>耗电量优化原则</h1><ul>
<li>当应用推到后台的时候，尽量减少应用的主动运行，防止CPU占用率异常。</li>
<li>前台运行的时候，不要去注册wake lock，此时的注册不仅没有意义，还会被计算到应用电量消耗中。注册后也要记住及时释放。</li>
<li>合理的设置手机各种传感器的使用时长和使用频率。</li>
</ul>
<h1 id="流畅度优化原则"><a href="#流畅度优化原则" class="headerlink" title="流畅度优化原则"></a>流畅度优化原则</h1><ul>
<li>布局优化<ul>
<li>尽量多使用RelativeLayout和LinearLayout，不要使用绝对布局。</li>
<li>使用<include>标签对布局进行复用。</include></li>
<li>使用ViewStub标签来加载一些不常用的布局。</li>
<li>动态地inflation view性能要比setVisiblity性能要好。</li>
<li>使用<merge>标签减少布局的嵌套。</merge></li>
<li>去掉多余的背景颜色，减少过度绘制。<ul>
<li>对于多层Layout只要留最上面一层的背景颜色即可。</li>
<li>对于使用Selector做背景的Layout，可将normal状态的color设置为“@android:color/transparent”。</li>
</ul>
</li>
<li>对于需要ImageView和TextView组合使用的场景可以使用compound drawables来代替。</li>
<li>尽量避免使用layout_weight。</li>
</ul>
</li>
<li>UI线程优化<ul>
<li>不要阻塞UI线程，即将占用CPU较多的数据操作尽可能放在一个单独的线程中进行。特别是针对网络访问、数据库查询和复杂的算法。</li>
<li>不要在UI线程之外操作UI。</li>
<li>避免在View的绘制过程中做对象的分配操作。</li>
</ul>
</li>
</ul>
<h1 id="网络优化原则"><a href="#网络优化原则" class="headerlink" title="网络优化原则"></a>网络优化原则</h1><ul>
<li>应用与后台服务器进行交互时，每次只在需要有变化的数据的时候再进行交互，数据不发生变化的时候不要重复传输。</li>
<li>在非WIFI的情况下，应用后台运行时尽量不去拉取。</li>
<li>对于日志传输，缓存下来并周期性的统一上报。</li>
<li>对于非WIFI情况下较费流量的功能，可以适当降低通信频率。</li>
<li>尽量合并网络请求以减少请求次数。</li>
</ul>
<h1 id="安装包瘦身优化原则"><a href="#安装包瘦身优化原则" class="headerlink" title="安装包瘦身优化原则"></a>安装包瘦身优化原则</h1><ul>
<li>代码部分<ul>
<li>删去未被引用的变量、方法和类等。</li>
<li>降低代码冗余度，提高复用率。</li>
<li>减少方法数。<ul>
<li>避免在内部类中访问外部类等私有方法／变量。</li>
<li>避免调用派生类中的未被覆盖的方法。</li>
<li>去掉部分类中不需要的get、set方法。</li>
</ul>
</li>
<li>代码混淆也能精简安装包。</li>
</ul>
</li>
<li>资源部分<ul>
<li>删去冗余资源。</li>
<li>进行资源混淆。</li>
<li>图片压缩，尽量使用JPG格式的图片，.9图化，使用频率较低的图片可以进行网络化。</li>
</ul>
</li>
<li>对安装包可以进行7zip压缩。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间好好总结了一下Android性能优化的内容。对于其中的各种原理和各种工具的使用方法这里就不多做介绍了，相关资料确实相当多。下面就是我对于常见的性能优化方法的一个简单的总结。&lt;/p&gt;
&lt;h1 id=&quot;内存优化原则&quot;&gt;&lt;a href=&quot;#内存优化原则&quot; class=&quot;h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NDK开发学习（二）：JNI规则</title>
    <link href="http://yoursite.com/2017/02/16/NDK%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJNI%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2017/02/16/NDK开发学习（二）：JNI规则/</id>
    <published>2017-02-16T04:20:00.000Z</published>
    <updated>2017-02-21T06:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<!--excerpt-->
<h5 id="JVM查找native方法"><a href="#JVM查找native方法" class="headerlink" title="JVM查找native方法"></a>JVM查找native方法</h5><p>JVM 查找 native 方法有两种方式：</p>
<ul>
<li>按照 JNI 规范的命名规则</li>
<li>调用 JNI 提供的 RegisterNatives 函数，将本地函数注册到 JVM 中。</li>
</ul>
<p>在编译我们所写的c/c++代码成动态库的时候，有两个头文件是需要的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; jni_md.h</div><div class="line"></div><div class="line">```c++</div><div class="line">#ifndef _JAVASOFT_JNI_MD_H_</div><div class="line">#define _JAVASOFT_JNI_MD_H_</div><div class="line"></div><div class="line">#define JNIEXPORT     __attribute__((visibility(&quot;default&quot;)))</div><div class="line">#define JNIIMPORT     __attribute__((visibility(&quot;default&quot;)))</div><div class="line">#define JNICALL</div><div class="line"></div><div class="line">typedef int jint;</div><div class="line">#ifdef _LP64 /* 64-bit */</div><div class="line">typedef long jlong;</div><div class="line">#else</div><div class="line">typedef long long jlong;</div><div class="line">#endif</div><div class="line"></div><div class="line">typedef signed char jbyte;</div><div class="line">#endif /* !_JAVASOFT_JNI_MD_H_ */</div></pre></td></tr></table></figure></p>
<p>当然，可以看到在mac平台下<code>JNIEXPORT</code>、<code>JNIIMPORT</code>、<code>JNICALL</code>并没有定义具体内容，是个空定义。</p>
<p>至于函数的命名规则，在<a href="/2017/02/15/NDK开发学习（一）：尝试JNI/" title="NDK开发学习（一）：尝试JNI">NDK开发学习（一）：尝试JNI</a>中有提到。</p>
<h5 id="JNI数据类型"><a href="#JNI数据类型" class="headerlink" title="JNI数据类型"></a>JNI数据类型</h5><p>首先是一个非常特殊的类型——<code>JNIEnv*</code>。它是定义任意 native 函数的第一个参数，指向 JVM 函数表的指针，函数表中的每一个入口指向一个 JNI 函数，每个函数用于访问 JVM 中特定的数据结构。</p>
<p>其余的下面两张图可以概括</p>
<img src="/2017/02/16/NDK开发学习（二）：JNI规则/NDK开发学习（二）：JNI规则_1.png" alt="NDK开发学习（二）：JNI规则_1.png" title="">
<img src="/2017/02/16/NDK开发学习（二）：JNI规则/NDK开发学习（二）：JNI规则_2.png" alt="NDK开发学习（二）：JNI规则_2.png" title="">
<p>值得注意的是JNI中所与Java中的基本数据类型对应的类型的值是可以在程序中直接使用到的，但是引用数据类型则不行。这是由于与基本类型不同，引用类型所传入的是一个指针类型，指向那个对象在JVM内存中的地址。要想从JVM内存中访问到这些数据，就需要通过<code>JNIEnv*</code>来实现。</p>
<p>##### </p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;!--excerpt--&gt;
&lt;h5 id=&quot;JVM查找native方法&quot;&gt;&lt;a href=&quot;#JVM查找native方法&quot; class=&quot;headerlink&quot; title=&quot;JVM查找native方法&quot;&gt;&lt;/a&gt;JVM查找native方法&lt;
    
    </summary>
    
      <category term="NDK开发学习" scheme="http://yoursite.com/categories/NDK%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>NDK开发学习（一）：尝试JNI</title>
    <link href="http://yoursite.com/2017/02/15/NDK%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%9D%E8%AF%95JNI/"/>
    <id>http://yoursite.com/2017/02/15/NDK开发学习（一）：尝试JNI/</id>
    <published>2017-02-15T03:12:30.000Z</published>
    <updated>2017-02-21T06:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<!--excerpt-->
<p>注：此过程在mac环境下</p>
<h3 id="JNI开发流程简介"><a href="#JNI开发流程简介" class="headerlink" title="JNI开发流程简介"></a>JNI开发流程简介</h3><ul>
<li>编写声明了 native 方法的 Java 类</li>
<li>将 Java 源代码编译成 class 字节码文件</li>
<li>用 javah -jni 命令生成<code>.h</code>头文件（javah 是 jdk 自带的一个命令，-jni 参数表示将 class 中用native 声明的函数生成 JNI 规则的函数）</li>
<li>用本地代码实现<code>.h头</code>文件中的函数</li>
<li>将本地代码编译成动态库（Windows：*.dll，linux/unix：*.so，mac os x：*.jnilib）</li>
<li>拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序</li>
</ul>
<h3 id="尝试JNI"><a href="#尝试JNI" class="headerlink" title="尝试JNI"></a>尝试JNI</h3><h5 id="一-定义一个native-函数"><a href="#一-定义一个native-函数" class="headerlink" title="一.定义一个native 函数"></a>一.定义一个native 函数</h5><blockquote>
<p>HelloWorld.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">    <span class="comment">//所需加载的动态库的完整路径	System.load("/Users/zhangyu/Desktop/JavaProjects/LearnJNI/jni/libHelloWorld.jnilib");</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">        String text = sayHello(<span class="string">"zpauly"</span>);</div><div class="line">        System.out.println(text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="二-使用将-java文件编译为-class文件"><a href="#二-使用将-java文件编译为-class文件" class="headerlink" title="二.使用将.java文件编译为.class文件"></a>二.使用将.java文件编译为.class文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac src/HelloWorld.java -d bin</div></pre></td></tr></table></figure>
<p>这里我使用-d命令将class文件生成到指定目录下</p>
<h5 id="三-根据-class文件生成-h头文件"><a href="#三-根据-class文件生成-h头文件" class="headerlink" title="三.根据.class文件生成.h头文件"></a>三.根据.class文件生成.h头文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javah -jni -classpath bin -d jni HelloWorld</div></pre></td></tr></table></figure>
<p>默认生成的头文件的名称为：包名+类名.h，如：若此处HelloWorld的包名为<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">javah -jni命令参数</div><div class="line"></div><div class="line">- classpath：类搜索路径，这里表示从当前的 bin 目录下查找</div><div class="line">- d：将生成的头文件放到当前的 jni 目录下</div><div class="line">- o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）</div><div class="line"></div><div class="line">此时生成的头文件为</div><div class="line"></div><div class="line">&gt; HelloWorld.h</div><div class="line"></div><div class="line">```c++</div><div class="line">/* DO NOT EDIT THIS FILE - it is machine generated */</div><div class="line">#include &lt;jni.h&gt;</div><div class="line">/* Header for class HelloWorld */</div><div class="line"></div><div class="line">#ifndef _Included_HelloWorld</div><div class="line">#define _Included_HelloWorld</div><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#endif</div><div class="line">/*</div><div class="line"> * Class:     HelloWorld</div><div class="line"> * Method:    sayHello</div><div class="line"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</div><div class="line"> */</div><div class="line">JNIEXPORT jstring JNICALL Java_HelloWorld_sayHello</div><div class="line">  (JNIEnv *, jclass, jstring);</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<h5 id="四-实现头文件中的函数"><a href="#四-实现头文件中的函数" class="headerlink" title="四.实现头文件中的函数"></a>四.实现头文件中的函数</h5><blockquote>
<p>HelloWorld.c</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HelloWorld.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     HelloWorld</div><div class="line"> * Method:    sayHello</div><div class="line"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_HelloWorld_sayHello</span><span class="params">(JNIEnv *env, jclass clazz, jstring j_str)</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory.\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Java String:%s\n"</span>, c_str);</div><div class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">"hello %s\n"</span>, c_str);</div><div class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h5 id="五-将写好的c-c-代码编译为本地动态库"><a href="#五-将写好的c-c-代码编译为本地动态库" class="headerlink" title="五.将写好的c/c++代码编译为本地动态库"></a>五.将写好的c/c++代码编译为本地动态库</h5><p>动态库命名规则：lib+动态库文件名+后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -dynamiclib -o jni/libHelloWorld.jnilib jni/HelloWorld.c -framework JavaVM -I/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/include/darwin</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>-dynamiclib：表示编译成动态链接库</li>
<li>-o：指定动态链接库编译后生成的路径及文件名</li>
<li>-framework JavaVM -I：编译 JNI 需要用到 JVM 的头文件(<code>jni.h</code>)，第一个目录是平台无关的，第二个目录是与操作系统平台相关的头文件</li>
</ul>
<h5 id="六-运行Java程序"><a href="#六-运行Java程序" class="headerlink" title="六.运行Java程序"></a>六.运行Java程序</h5><p>运行效果</p>
<img src="/2017/02/15/NDK开发学习（一）：尝试JNI/NDK开发学习（一）：尝试JNI_1.png" alt="NDK开发学习（一）：尝试JNI_1.png" title="">
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;!--excerpt--&gt;
&lt;p&gt;注：此过程在mac环境下&lt;/p&gt;
&lt;h3 id=&quot;JNI开发流程简介&quot;&gt;&lt;a href=&quot;#JNI开发流程简介&quot; class=&quot;headerlink&quot; title=&quot;JNI开发流程简介&quot;&gt;&lt;/a&gt;JNI开发流
    
    </summary>
    
      <category term="NDK开发学习" scheme="http://yoursite.com/categories/NDK%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>了解Annotation-Processing-Tool</title>
    <link href="http://yoursite.com/2017/01/21/%E4%BA%86%E8%A7%A3Annotation-Processing-Tool/"/>
    <id>http://yoursite.com/2017/01/21/了解Annotation-Processing-Tool/</id>
    <published>2017-01-21T06:29:08.000Z</published>
    <updated>2017-02-21T06:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>我知道APT（Annotation-Processing-Tool）还得从很有名的一个Android开源库<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a>说起。起初我对其并不在意，以为它内部的实现只是简单的反射，但是某一次当我看到一篇文章內这么说：</p>
<blockquote>
<p>ButterKnife实现了编译期注入，效率远高于采用反射机制</p>
</blockquote>
<p>于是便对这个编译期注入起了兴趣，通过一番学习总算是了解了APT这么个神奇的东西。</p>
<p>注：主要学习资料为官方文档</p>
<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>注解处理器是 javac 自带的一个工具，用来在编译时期扫描处理注解信息。你可以为某些注解注册自己的注解处理器。</p>
<p>一个特定注解的处理器以 java 源代码（或者已编译的字节码）作为输入，然后生成一些文件（通常是<code>.java</code>文件）作为输出。那意味着什么呢？你可以生成 java 代码！这些 java 代码在生成的<code>.java</code>文件中。因此你不能改变已经存在的java类，例如添加一个方法。这些生成的 java 文件跟其他手动编写的 java 源代码一样，将会被 javac 编译。</p>
<h3 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h3><p>让我们来看一下处理器的 API。所有的处理器都继承了<code>AbstractProcessor</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> javax.annotation.processing.AbstractProcessor;</div><div class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</div><div class="line"><span class="keyword">import</span> javax.annotation.processing.RoundEnvironment;</div><div class="line"><span class="keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;</div><div class="line"><span class="keyword">import</span> javax.annotation.processing.SupportedSourceVersion;</div><div class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</div><div class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations,</span></span></div><div class="line">			RoundEnvironment env) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">		Set&lt;String&gt; annotataions = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</div><div class="line">	    annotataions.add(<span class="string">"com.example.MyAnnotation"</span>);</div><div class="line">	    <span class="keyword">return</span> annotataions;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> SourceVersion.latestSupported();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.init(processingEnv);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>init(ProcessingEnvironment processingEnv)</code> ：所有的注解处理器类<strong>都必须有一个无参构造函数</strong>。然而，有一个特殊的方法<code>init()</code>，它会被注解处理工具调用，以<code>ProcessingEnvironment</code>作为参数。ProcessingEnvironment 提供了一些实用的工具类<code>Elements</code>, <code>Types</code>和<code>Filer</code>。我们在后面将会使用到它们。</p>
</li>
<li><p><code>process(Set annoations, RoundEnvironment env)</code> ：这类似于每个处理器的<code>main()</code>方法。你可以在这个方法里面编码实现扫描，处理注解，生成 java 文件。使用<code>RoundEnvironment</code> 参数，你可以查询被特定注解标注的元素（原文：you can query for elements annotated with a certain annotation ）。后面我们将会看到详细内容。</p>
</li>
<li><p><code>getSupportedAnnotationTypes()</code>：在这个方法里面你必须指定哪些注解应该被注解处理器注册。注意，它的返回值是一个<code>String</code>集合，包含了你的注解处理器想要处理的注解类型的全称。换句话说，你在这里定义你的注解处理器要处理哪些注解。</p>
</li>
<li><p><code>getSupportedSourceVersion()</code> ： 用来指定你使用的 java 版本。通常你应该返回<code>SourceVersion.latestSupported()</code> 。不过，如果你有足够的理由坚持用 java 6 的话，你也可以返回<code>SourceVersion.RELEASE_6</code>。我建议使用<code>SourceVersion.latestSupported()</code>。在 Java 7 中，你也可以使用注解的方式来替代重写<code>getSupportedAnnotationTypes()</code>和 <code>getSupportedSourceVersion()</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SupportedSourceVersion</span>(value=SourceVersion.RELEASE_7)</div><div class="line"><span class="meta">@SupportedAnnotationTypes</span>(&#123;</div><div class="line">   <span class="comment">// Set of full qullified annotation type names</span></div><div class="line">	<span class="string">"com.example.MyAnnotation"</span>,</div><div class="line">	<span class="string">"com.example.AnotherAnnotation"</span></div><div class="line"> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations,</span></span></div><div class="line">			RoundEnvironment env) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.init(processingEnv);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>由于兼容性问题，特别是对于 android ，建议重写<code>getSupportedAnnotationTypes()</code> 和 <code>getSupportedSourceVersion()</code> ，而不是使用 <code>@SupportedAnnotationTypes</code> 和 <code>@SupportedSourceVersion</code>。</p>
<h3 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h3><p>在你的 .jar 文件中，你必须打包一个特殊的文件<code>javax.annotation.processing.Processor</code>到<code>META-INF/services</code>目录下。因此你的 .jar 文件目录结构看起来就你这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MyProcess.jar</div><div class="line">	-com</div><div class="line">		-example</div><div class="line">			-MyProcess.class</div><div class="line">	-META-INF</div><div class="line">		-services</div><div class="line">			-javax.annotation.processing.Processor</div></pre></td></tr></table></figure>
<p><code>javax.annotation.processing.Processor</code> 文件的内容是一个列表，每一行是一个注解处理器的全称。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">com.example.MyProcess</div><div class="line">com.example.AnotherProcess</div></pre></td></tr></table></figure>
<h3 id="亲身实践"><a href="#亲身实践" class="headerlink" title="亲身实践"></a>亲身实践</h3><p>这里我就不多加介绍了，我模仿ButterKnife写了一个<a href="https://github.com/zpauly/BindViewByApt" target="_blank" rel="external">小例子</a>，感兴趣可以看看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我知道APT（Annotation-Processing-Tool）还得从很有名的一个Android开源库&lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
    
      <category term="Annotation-Processing-Tool" scheme="http://yoursite.com/tags/Annotation-Processing-Tool/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化入门资料</title>
    <link href="http://yoursite.com/2016/12/25/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%85%A5%E9%97%A8%E8%B5%84%E6%96%99/"/>
    <id>http://yoursite.com/2016/12/25/Android插件化入门资料/</id>
    <published>2016-12-25T13:33:10.000Z</published>
    <updated>2017-02-07T09:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>最近一直在学习Android Framework层的源码，而插件化自当是我想到的关于这方面的最好实践。但毕竟插件化的难度还是很大的，因此在插件化的入门过程中，自己总是会绕得云里雾里。不过幸运的是我发现了一个系列的文章，可以说是大大提高了我这方面的学习效率。</p>
<!--excerpt-->
<p><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/" target="_blank" rel="external">Hook机制之动态代理</a></p>
<p><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="external">Hook机制之Binder Hook</a></p>
<p><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="external">Hook机制之AMS&amp;PMS</a></p>
<p><a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="external">Activity生命周期管理</a></p>
<p><a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank" rel="external">插件加载机制</a></p>
<p><a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/" target="_blank" rel="external">广播的管理</a></p>
<p><a href="http://weishu.me/2016/05/11/understand-plugin-framework-service/" target="_blank" rel="external">Service的插件化</a></p>
<p><a href="http://weishu.me/2016/07/12/understand-plugin-framework-content-provider/" target="_blank" rel="external">ContentProvider的插件化</a></p>
<p>在这里做个分享，顺便自己也收藏一下，以后要是有什么记不得的也常来看看(ง •̀_•́)ง</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;最近一直在学习Android Framework层的源码，而插件化自当是我想到的关于这方面的最好实践。但毕竟插件化的难度还是很大的，因此在插件化的入门过程中，自己总是会绕得云里雾里。不过幸运的是我发现了一个系列的文章，可以说是大大提高了我
    
    </summary>
    
      <category term="Android插件化" scheme="http://yoursite.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="插件化" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Framework" scheme="http://yoursite.com/tags/Android-Framework/"/>
    
  </entry>
  
  <entry>
    <title>带你看Glide源码</title>
    <link href="http://yoursite.com/2016/12/21/%E5%B8%A6%E4%BD%A0%E7%9C%8BGlide%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2016/12/21/带你看Glide源码/</id>
    <published>2016-12-21T06:22:16.000Z</published>
    <updated>2017-02-21T06:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着Android开发的愈渐火热，各种Android的图片加载库也曾出不穷，比较有名的有：<strong>Fresco</strong>、<strong>Picasso</strong>、<strong>Universal Image Loader</strong>等等。在这篇文章中，我会通过源码来简单地分析一下<strong>Glide</strong>使用时所发生的事情。</p>
<p>###使用方法<br>对于<strong>Glide</strong>的使用方法不是本文的重点，在这里就不多说了，这里贴出<strong>Glide</strong>的Github<a href="https://github.com/bumptech/glide" target="_blank" rel="external">地址</a>，如果对使用方法有什么疑问的就上官方去看看吧。这里我们从Glide最简单的三行使用方法入手进行分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Glide.with(...)</div><div class="line">        .load(...)</div><div class="line">        .into(...);</div></pre></td></tr></table></figure></p>
<p>###流程分析<br>首先我们进入<strong>Glide</strong>类看看<strong>with()</strong>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;   </div><div class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get(); </div><div class="line">    <span class="keyword">return</span> retriever.get(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到<strong>with()</strong>方法是<strong>Glide</strong>类中的一个静态方法，它会创建一个<strong>RequestManagerRetriever</strong>对象，在这里我们先不看这个类在创建过程中发生的事情，先看看它通过传入的<strong>Context</strong>对象所返回的这个<strong>RequestManager</strong>对象。</p>
<p>对于<strong>RequestManager</strong>这个类，官方文档是这样描述的：<br><em>A class for managing and starting requests for Glide. Can use activity, fragment and connectivity lifecycle events to intelligently stop, start, and restart requests. Retrieve either by instantiating a new object, or to take advantage built in Activity and Fragment lifecycle handling, use the static Glide.load methods with your Fragment or Activity.</em><br>本人英文一般，就不逐字逐句地翻译了。总之，对于<strong>RequestManager</strong>这个类的定位就是对图片加载请求进行管理的类，并且它会根据与其产生联系的<strong>Context</strong>对象的生命周期来管理图片加载的过程。因此，图片资源加载进<strong>ImageView</strong>的过程事实上是由它来一手掌管的。</p>
<p>知道了这些，我们接下来来看看它的<strong>load()</strong>方法，也就是我们将资源路径传入的这个方法，这里我们以传入一个<strong>Uri</strong>为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;Uri&gt; <span class="title">load</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (DrawableTypeRequest&lt;Uri&gt;) fromUri().load(uri);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法中使用了<strong>DrawableTypeRequest</strong>中的<strong>load()</strong>方法去加载这个uri：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">load</span><span class="params">(ModelType model)</span> </span>&#123;    </div><div class="line">    <span class="keyword">super</span>.load(model);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的泛型参数<strong>ModelType</strong>在这里所对应的实际类型就是我们传入的资源类型<strong>Uri</strong>，并且调用了<strong>DrawableRequestBuilder</strong>的父类方法<strong>load()</strong>来处理。</p>
<p><strong>GenericRequestBuilder</strong>就是<strong>DrawableRequestBuilder</strong>的父类，这个类及其子类的作用就是用于请求加载的。我们来看看里面刚刚提到的<strong>load()</strong>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class="title">load</span><span class="params">(ModelType model)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.model = model;</div><div class="line">    isModelSet = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们发现，<strong>load()</strong>方法仅仅是将资源——这里就是我们的图片资源Uri赋值给了一个变量<strong>model</strong>，至于图片资源究竟是怎么加载进<strong>ImageView</strong>的，我们回到这里实际进行加载请求的类<strong>DrawableRequestBuilder</strong>去看看它当中被我们最后调用的<strong>into()</strong>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Target&lt;GlideDrawable&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.into(view);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和<strong>load()</strong>方法相同，这里也调用了父类<strong>GenericRequestBuilder</strong>的<strong>into()</strong>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于这个方法我们只看最后一句代码。在这里又再次回到一开始的<strong>Glide</strong>，并调用了其中的<strong>buildImageViewTarget()</strong>方法，而在这个方法中传入了一个<strong>GlideDrawable</strong>对象<strong>transcodedClass</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;R&gt; <span class="function">Target&lt;R&gt; <span class="title">buildImageViewTarget</span><span class="params">(ImageView imageView, Class&lt;R&gt; transcodedClass)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodedClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们继续跟踪下去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;Z&gt; <span class="function">Target&lt;Z&gt; <span class="title">buildTarget</span><span class="params">(ImageView view, Class&lt;Z&gt; clazz)</span> </span>&#123;    </div><div class="line">    <span class="keyword">if</span> (GlideDrawable.class.isAssignableFrom(clazz)) &#123;</div><div class="line">        <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> GlideDrawableImageViewTarget(view);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</div><div class="line">        <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</div><div class="line">        <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled class: "</span> + clazz                + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过反复地辗转我们终于发现了上面我们传入<strong>into()</strong>方法中的是一个和我们所要将图片加载进的<strong>ImageView</strong>相关的<strong>GlideDrawableImageViewTarget</strong>对象。我们先记住这一点，不继续深究下去，先回头看看那个<strong>GenericRequestBuilder</strong>中的<strong>into()</strong>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    Request request = buildRequest(target);</div><div class="line">    target.setRequest(request);</div><div class="line">    ......</div><div class="line">    requestTracker.runRequest(request);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码所做的事情根据方法名很容易就能猜到，它先根据传入的一个<strong>Target</strong>对象创建一个<strong>Request</strong>，并将两者建立关联，最后执行加载请求。</p>
<p>这里我们反过来会发现，这个<strong>Target</strong>的实际对象就是我们刚刚所说的那个<strong>GlideDrawable</strong>，另外谈到请求，是不是想到我们前面<strong>load()</strong>进去的那个<strong>Uri</strong>对象了呢？一阵云里雾里，整个内容终于联系了起来，那么我们就先来看看这个<strong>Request</strong>对象究竟是怎么创建的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequest</span><span class="params">(Target&lt;TranscodeType&gt; target)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">return</span> buildRequestRecursive(target, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里又将那个<strong>Target</strong>对象传进一个<strong>buildRequestRecursive()</strong>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">return</span> obtainRequest(target, sizeMultiplier, priority, parentCoordinator);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于这个方法，我们重点来关注一下其中的一行代码，其中涉及了<strong>obtainRequest()</strong>方法，这个方法有四个参数，其中最重要的就是第一个，这里将刚刚的<strong>Target</strong>对象给传了进去，我们接下来看一下这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(Target&lt;TranscodeType&gt; target,</span></span></div><div class="line">        <span class="keyword">float</span> sizeMultiplier, Priority priority,</div><div class="line">        RequestCoordinator requestCoordinator) &#123;</div><div class="line">    <span class="keyword">return</span> GenericRequest.obtain(</div><div class="line">            loadProvider,</div><div class="line">            model,</div><div class="line">            signature,</div><div class="line">            context,</div><div class="line">            priority,</div><div class="line">            target,</div><div class="line">            sizeMultiplier,</div><div class="line">            placeholderDrawable,</div><div class="line">            placeholderId,</div><div class="line">            errorPlaceholder,</div><div class="line">            errorId,</div><div class="line">            fallbackDrawable,</div><div class="line">            fallbackResource,</div><div class="line">            requestListener,</div><div class="line">            requestCoordinator,</div><div class="line">            glide.getEngine(),</div><div class="line">            transformation,</div><div class="line">            transcodeClass,</div><div class="line">            isCacheable,</div><div class="line">            animationFactory,</div><div class="line">            overrideWidth,</div><div class="line">            overrideHeight,</div><div class="line">            diskCacheStrategy);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法中只做了一件事，调用了<strong>GenericRequest</strong>类的静态方法<strong>obtain()</strong>，并且传入了很多的参数，这里注意其中的参数<strong>target</strong>，即上面的<strong>GlideDrawableImageViewTarget</strong>对象，另外还有就是这里执行了<strong>Glide</strong>中的<strong>getEngine()</strong>方法，还有资源模型<strong>model</strong>。然后继续往下看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A, T, Z, R&gt; <span class="function">GenericRequest&lt;A, T, Z, R&gt; <span class="title">obtain</span><span class="params">(</span></span></div><div class="line">        LoadProvider&lt;A, T, Z, R&gt; loadProvider,</div><div class="line">        A model,</div><div class="line">        Key signature,</div><div class="line">        Context context,</div><div class="line">        Priority priority,</div><div class="line">        Target&lt;R&gt; target,</div><div class="line">        <span class="keyword">float</span> sizeMultiplier,</div><div class="line">        Drawable placeholderDrawable,</div><div class="line">        <span class="keyword">int</span> placeholderResourceId,</div><div class="line">        Drawable errorDrawable,</div><div class="line">        <span class="keyword">int</span> errorResourceId,</div><div class="line">        Drawable fallbackDrawable,</div><div class="line">        <span class="keyword">int</span> fallbackResourceId,</div><div class="line">        RequestListener&lt;? <span class="keyword">super</span> A, R&gt; requestListener,</div><div class="line">        RequestCoordinator requestCoordinator,</div><div class="line">        Engine engine,</div><div class="line">        Transformation&lt;Z&gt; transformation,</div><div class="line">        Class&lt;R&gt; transcodeClass,</div><div class="line">        <span class="keyword">boolean</span> isMemoryCacheable,</div><div class="line">        GlideAnimationFactory&lt;R&gt; animationFactory,</div><div class="line">        <span class="keyword">int</span> overrideWidth,</div><div class="line">        <span class="keyword">int</span> overrideHeight,</div><div class="line">        DiskCacheStrategy diskCacheStrategy) &#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    GenericRequest&lt;A, T, Z, R&gt; request = (GenericRequest&lt;A, T, Z, R&gt;) REQUEST_POOL.poll();</div><div class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</div><div class="line">        request = <span class="keyword">new</span> GenericRequest&lt;A, T, Z, R&gt;();</div><div class="line">    &#125;</div><div class="line">    request.init(loadProvider,</div><div class="line">            model,</div><div class="line">            signature,</div><div class="line">            context,</div><div class="line">            priority,</div><div class="line">            target,</div><div class="line">            sizeMultiplier,</div><div class="line">            placeholderDrawable,</div><div class="line">            placeholderResourceId,</div><div class="line">            errorDrawable,</div><div class="line">            errorResourceId,</div><div class="line">            fallbackDrawable,</div><div class="line">            fallbackResourceId,</div><div class="line">            requestListener,</div><div class="line">            requestCoordinator,</div><div class="line">            engine,</div><div class="line">            transformation,</div><div class="line">            transcodeClass,</div><div class="line">            isMemoryCacheable,</div><div class="line">            animationFactory,</div><div class="line">            overrideWidth,</div><div class="line">            overrideHeight,</div><div class="line">            diskCacheStrategy);</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一段看上去有点长，但是其实也只涉及到了一个方法<strong>init()</strong>，这个方法同样接受了很多参数，并且在这个方法中，做的也只有一件事，就是将这些传入的参数一一赋值给<strong>GenericRequest</strong>的成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(</span></span></div><div class="line">        LoadProvider&lt;A, T, Z, R&gt; loadProvider,</div><div class="line">        A model,</div><div class="line">        Key signature,</div><div class="line">        Context context,</div><div class="line">        Priority priority,</div><div class="line">        Target&lt;R&gt; target,</div><div class="line">        <span class="keyword">float</span> sizeMultiplier,</div><div class="line">        Drawable placeholderDrawable,</div><div class="line">        <span class="keyword">int</span> placeholderResourceId,</div><div class="line">        Drawable errorDrawable,</div><div class="line">        <span class="keyword">int</span> errorResourceId,</div><div class="line">        Drawable fallbackDrawable,</div><div class="line">        <span class="keyword">int</span> fallbackResourceId,</div><div class="line">        RequestListener&lt;? <span class="keyword">super</span> A, R&gt; requestListener,</div><div class="line">        RequestCoordinator requestCoordinator,</div><div class="line">        Engine engine,</div><div class="line">        Transformation&lt;Z&gt; transformation,</div><div class="line">        Class&lt;R&gt; transcodeClass,</div><div class="line">        <span class="keyword">boolean</span> isMemoryCacheable,</div><div class="line">        GlideAnimationFactory&lt;R&gt; animationFactory,</div><div class="line">        <span class="keyword">int</span> overrideWidth,</div><div class="line">        <span class="keyword">int</span> overrideHeight,</div><div class="line">        DiskCacheStrategy diskCacheStrategy) &#123;</div><div class="line">    <span class="keyword">this</span>.loadProvider = loadProvider;</div><div class="line">    <span class="keyword">this</span>.model = model;</div><div class="line">    <span class="keyword">this</span>.signature = signature;</div><div class="line">    <span class="keyword">this</span>.fallbackDrawable = fallbackDrawable;</div><div class="line">    <span class="keyword">this</span>.fallbackResourceId = fallbackResourceId;</div><div class="line">    <span class="keyword">this</span>.context = context.getApplicationContext();</div><div class="line">    <span class="keyword">this</span>.priority = priority;</div><div class="line">    <span class="keyword">this</span>.target = target;</div><div class="line">    <span class="keyword">this</span>.sizeMultiplier = sizeMultiplier;</div><div class="line">    <span class="keyword">this</span>.placeholderDrawable = placeholderDrawable;</div><div class="line">    <span class="keyword">this</span>.placeholderResourceId = placeholderResourceId;</div><div class="line">    <span class="keyword">this</span>.errorDrawable = errorDrawable;</div><div class="line">    <span class="keyword">this</span>.errorResourceId = errorResourceId;</div><div class="line">    <span class="keyword">this</span>.requestListener = requestListener;</div><div class="line">    <span class="keyword">this</span>.requestCoordinator = requestCoordinator;</div><div class="line">    <span class="keyword">this</span>.engine = engine;</div><div class="line">    <span class="keyword">this</span>.transformation = transformation;</div><div class="line">    <span class="keyword">this</span>.transcodeClass = transcodeClass;</div><div class="line">    <span class="keyword">this</span>.isMemoryCacheable = isMemoryCacheable;</div><div class="line">    <span class="keyword">this</span>.animationFactory = animationFactory;</div><div class="line">    <span class="keyword">this</span>.overrideWidth = overrideWidth;</div><div class="line">    <span class="keyword">this</span>.overrideHeight = overrideHeight;</div><div class="line">    <span class="keyword">this</span>.diskCacheStrategy = diskCacheStrategy;</div><div class="line">    status = Status.PENDING;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里对于加载请求的设置几本完成，我们再回去看看那句运行加载的代码<strong>requestTracker.runRequest(request);</strong>所做的具体的事情：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (!isPaused) &#123;</div><div class="line">        request.begin();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里调用了刚刚设置好的<strong>Request</strong>对象的<strong>begin()</strong>方法，而这里的<strong>Request</strong>对象的实际类型就是上面我们所看到的<strong>GenericRequest</strong>对象。于是，我们来看看它的<strong>begin()</strong>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class="line">          target.onLoadStarted(getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们需要关注的就是一个<strong>Target</strong>对象的<strong>onLoadStarted()</strong>方法，在这里我们记起这个<strong>Target</strong>对象的实际类型就是上面的<strong>init()</strong>方法中所设置的<strong>GlideDrawableImageViewTarget</strong>对象。也许你会认为这个<strong>begin()</strong>方法就是资源加载进<strong>ImageView</strong>的关键，但是当我们点进去查看它的<strong>begin()</strong>方法时却发现并不如我们所想，它只是为我们的<strong>ImageView</strong>设置了一个占位图，并没有做其他的事情。但是我们在查看<strong>GlideDrawableImageViewTarget</strong>的源码的时候，我们发现了这么一个方法<strong>onResourceReady()</strong>，在这个方法中有这么一句代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setResource(resource);</div></pre></td></tr></table></figure></p>
<p>接着看看<strong>setResource()</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(GlideDrawable resource)</span> </span>&#123;</div><div class="line">    view.setImageDrawable(resource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的resource我们猜应该就是图片资源了，也会是说这里所做的事情就是最后将图片呈现在<strong>ImageView</strong>上，但程序究竟是怎么到这里的呢，我们想到了上面的<strong>getEngine()</strong>方法，于是我们来看看这里所做的事情：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> engine;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<strong>Engine</strong>又是一个非常重要的类，我们来看看这个类的官方介绍：<br><em>Responsible for starting loads and managing active and cached resources.</em><br>我们发现这个类就是真正用来管理加载的类。但是这个不是我这篇文章的重点，关于它所作的事情我会在后面的文章中对它进行简析。既然这个<strong>Engine</strong>对象是用来加载资源的，那么我们就想到了一开始的那个上面另外一个要记住的<strong>model</strong>，看看它们是怎么运用的。要想知道这到底是怎么使用的，我在这里贴出最重要的一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLoadComplete</span><span class="params">(Resource resource)</span> </span>&#123;</div><div class="line">      manager.onResourceReady(resource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是<strong>EngineRunnable</strong>类中的，这个类从名字就可以看出来它的作用就是响应<strong>Engine</strong>的。而这里的<strong>onResourceReady()</strong>则是触发了<strong>GenericRequest</strong>中的一个回调<strong>onResourceReady()</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    onResourceReady(resource, (R) received);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里又调用了该类中的一个重载方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, R result)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</div><div class="line">        isFirstResource)) &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    notifyLoadSuccess();</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到了，这个方法使用到了<strong>model</strong>，而这个方法则属于一个<strong>RequestListener</strong>回调接口，这个回调接口究竟会在哪里被调用呢，其实就是我们上面提到的<strong>GlideDrawableImageViewTarget</strong>的<strong>onResourceReady()</strong>，而在这个方法中，另一个参数<strong>target</strong>在这里的实际类型就是<strong>GlideDrawableImageViewTarget</strong>。到这里我们终于是弄明白整个图片资源的加载过程了。</p>
<p>至此Glide加载图片的调用链大致是搞明白了，里面涉及了大量的设计模式，因此十分复杂，但是原理很简单易懂，理清楚之后便十分清晰明了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着Android开发的愈渐火热，各种Android的图片加载库也曾出不穷，比较有名的有：&lt;strong&gt;Fresco&lt;/strong&gt;、&lt;strong&gt;Picasso&lt;/strong&gt;、&lt;strong&gt;Universal Image Loader&lt;/strong&gt;等等。在
    
    </summary>
    
      <category term="拆轮子系列" scheme="http://yoursite.com/categories/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Picasso源码学习（二）</title>
    <link href="http://yoursite.com/2016/10/19/Picasso%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/19/Picasso源码学习（二）/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2017-02-06T15:17:37.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>继上一篇文章简单分析了一下<strong><em>Picasso</em></strong>的图片加载流程，这次就接着小小地研究一把图片加载中最为重要的一个部分——缓存机制。当然，这段源码阅读过程自然是以上一篇文章中<a href="https://zpauly.github.io/2016/10/18/Picasso%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external"><strong><em>Picasso请求加载流程</em></strong></a>为基础的。</p>
<!--excerpt-->
<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>从上一篇的内容来看，在图片加载的过程中调用了一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Picasso.quickMemoryCacheCheck(target, requestKey);</div></pre></td></tr></table></figure>
<p>这个方法从名字里也可以看出来它的作用是从内存中检查所需的<strong><em>Bitmap</em></strong>资源是否已经存在，如果存在则从缓存中取出来，所以我们首先来看看这个方法干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">Bitmap <span class="title">quickMemoryCacheCheck</span><span class="params">(Object target, String key)</span> </span>&#123;</div><div class="line">  <span class="comment">//通过键key作为索引来从缓存中查找Bitmap对象，如果没有则返回null</span></div><div class="line">    Bitmap cached = cache.get(key);</div><div class="line">  </div><div class="line">    cancelExistingRequest(target, key);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</div><div class="line">      stats.cacheHit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cached;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里关心的主要是<strong><em>cache.get()</em></strong>的调用，这里的<strong><em>cache</em></strong>是一个<strong><em>Cache</em></strong>对象，<strong><em>Cache</em></strong>是一个被设计来专门用于缓存的接口，不是很复杂，在看看<strong><em>cache</em></strong>的具体类型之前，先来看看这个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</div><div class="line">  <span class="comment">//根据特定的键来从缓存中获取图片资源，如果缓存中没有则返回null</span></div><div class="line">  <span class="function">Bitmap <span class="title">get</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">//将一个String对象和一个Bitmap对象以键值对的形式存入缓存中</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Bitmap bitmap)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">//返回当前缓存中的内容大小</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">//返回缓存所能存放的最大数据量</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">//一个空缓存对象，表示没有存储任何内容</span></div><div class="line">  Cache NONE = <span class="keyword">new</span> Cache() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">      <span class="comment">// Ignore.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSize</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每一个方法这里都注释了，也极易明白。再回过头来看看<strong><em>cache</em></strong>的创建过程来看看它的具体类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">memoryCache = <span class="keyword">new</span> LruCache(context);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Picasso(context, loader, service, memoryCache, stats);</div></pre></td></tr></table></figure>
<p>这里的<strong><em>memoryCache</em></strong>的类型便是<strong><em>Cache</em></strong>类型，而这个创建的代码就在是在<strong><em>Picasso.Builder</em></strong>的构造函数中，最后被传入<strong><em>Picasso</em></strong>的构造函数，赋值给<strong><em>cache</em></strong>。从这里可以看出来它的具体类型是<strong><em>LruCache</em></strong>。从名字中不难猜出，它实际上是通过使用<strong><em>LRU</em></strong>算法实现的缓存存取过程的。这里的<strong><em>LruCache</em></strong>并不是我们熟知的<strong><em>Android</em></strong>中<strong><em>support-v4</em></strong>包中的类<strong><em>LruCache</em></strong>，但其实现原理都是一摸一样的，都是采用<strong><em>LRU</em></strong>算法将所需缓存的数据存进一个<strong><em>LinkedHashMap</em></strong>中。</p>
<p>上面所提到的便是<strong><em>Picasso</em></strong>的内存缓存机制，那么它的磁盘缓存是通过什么方法实现的呢。其实<strong><em>Picasso</em></strong>的磁盘缓存是通过<strong><em>OkHttp</em></strong>的缓存功能来实现的。这里我们回到<strong><em>Loader</em></strong>类中的<strong><em>createDefaultLoader</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Loader <span class="title">createDefaultLoader</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class.forName(<span class="string">"com.squareup.okhttp.OkHttpClient"</span>);</div><div class="line">      <span class="keyword">return</span> OkHttpLoaderCreator.create(context);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> UrlConnectionLoader(context);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个方法的执行过程便是在发现内存缓存中没有所想要的内容时开始通过网络发起请求的时候所发生的。这里先前介绍过实际请求调用的便是其中<strong><em>OkHttpLoader</em></strong>中的<strong><em>loader()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">load</span><span class="params">(String url, <span class="keyword">boolean</span> localCacheOnly)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    HttpURLConnection connection = client.open(<span class="keyword">new</span> URL(url));</div><div class="line">    connection.setUseCaches(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">if</span> (localCacheOnly) &#123;</div><div class="line">      connection.setRequestProperty(<span class="string">"Cache-Control"</span>, <span class="string">"only-if-cached"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> fromCache = parseResponseSourceHeader(connection.getHeaderField(RESPONSE_SOURCE));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(connection.getInputStream(), fromCache);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>从这里我们便可以一眼看出来，在发起请求的时候，所设置的属性便是对请求内容进行缓存，也就是说如果<strong><em>OkHttp</em></strong>的缓存中已经有了所需的图片资源，那就直接获取，如果没有则继续请求。</p>
<p>通过我们的分析算是证实了<strong><em>Picasso</em></strong>的磁盘缓存机制是通过<strong><em>OkHttp</em></strong>来实现的。但是，Square公司早已推了<strong><em>OkHttp3</em></strong>，但即使是checkout到最新版本的<strong><em>Picasso</em></strong>也并没有从中发现<strong><em>OkHttp3</em></strong>到影子，这就带来一个问题，实际使用<strong><em>Picasso</em></strong>到时候就会由于出现没有使用<strong><em>OkHttp</em></strong>的情况而出现无法使用磁盘缓存的问题。这里便向想要结局这个问题的同学推荐一个库<a href="https://github.com/JakeWharton/picasso2-okhttp3-downloader" target="_blank" rel="external">picasso2-okhttp3-downloader</a>，这时Jake大神为这个问题所专门写的，其中的实现机制其实很简单，和<strong><em>Picasso</em></strong>内的<strong><em>OkHttpLoader</em></strong>如出一辙，一看便知。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这部分的不长，主要就是我自己查看<strong><em>Picasso</em></strong>缓存机制的一个简单的流程记录，内容也很简单，同时又不可或缺所以就单独拿出来了，还是恨通俗易懂的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;继上一篇文章简单分析了一下&lt;strong&gt;&lt;em&gt;Picasso&lt;/em&gt;&lt;/strong&gt;的图片加载流程，这次就接着小小地研究一把图片加载中最为重要的一个部分——缓存机制。当然，这段源码阅读过程自然是以上一篇文章中&lt;a href=&quot;ht
    
    </summary>
    
      <category term="拆轮子系列" scheme="http://yoursite.com/categories/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Picasso" scheme="http://yoursite.com/tags/Picasso/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Picasso源码学习（一）</title>
    <link href="http://yoursite.com/2016/10/18/Picasso%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/18/Picasso源码学习（一）/</id>
    <published>2016-10-18T12:53:34.000Z</published>
    <updated>2017-02-06T15:17:47.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<img src="/2016/10/18/Picasso源码学习（一）/picasso_cover.png" alt="picasso_cover.png" title="">
<p>从这里开始我会开始阅读一款来自于Square的大名鼎鼎的图片处理库<strong><em>Picasso</em></strong>，将这个过程以博客的形式记录下来，一方面是一种学习记录，另一方面也是一种督促啦。</p>
<!--excerpt-->
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>一切的第一步当然是首先把源码从github上clone下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/square/picasso.git</div></pre></td></tr></table></figure>
<p>稍等片刻，<strong><em>Picasso</em></strong>的源码就被clone到了自己的电脑上。</p>
<p>当然，现在我们这里的就是<strong><em>Picasso</em></strong>的作者所commit的最新的代码，但是所要看的并不是这个内容，这里需要选择一个release版本。</p>
<img src="/2016/10/18/Picasso源码学习（一）/picasso0.png" alt="picasso0.png" title="">
<p>之所以选的是最早的1.0.0版本，是因为作为最早的版本，后面的所有版本都是基于这个版本进行编写的，阅读最早的版本可以更好地了解整个项目的构架。另外，作为最早的版本，这个版本肯定也是所有版本里最容易阅读的。我们接着将项目checkout到该版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout dea2e24</div></pre></td></tr></table></figure>
<p>接下来就是酥爽的源码阅读之旅了。</p>
<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><h3 id="大致了解"><a href="#大致了解" class="headerlink" title="大致了解"></a>大致了解</h3><p>根据<strong><em>Picasso</em></strong>的使用方法，首先我们会使用 <code>Picasso.with(context)</code>，因此我们就从这里开始看看在我们使用<strong><em>Picasso</em></strong>的时候它都做了些什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">//构造Picasso对象</span></div><div class="line">      singleton = <span class="keyword">new</span> Builder(context).build();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> singleton;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这是一个<strong><em>Picasso</em></strong>中的静态方法，很明显是构造了一个<strong><em>Picasso</em></strong>的单例，并且在代码构架中使用了Build模式建立了这个对象。这里的关键是<strong><em>Builder</em></strong>对象的构造过程里都做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">this</span>.context;</div><div class="line">  	<span class="comment">//创建用于加载图片的对象loader</span></div><div class="line">      <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</div><div class="line">        loader = Utils.createDefaultLoader(context);</div><div class="line">      &#125;</div><div class="line">  	<span class="comment">//创建用于缓存的对象memoryCache</span></div><div class="line">      <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</div><div class="line">        memoryCache = <span class="keyword">new</span> LruCache(context);</div><div class="line">      &#125;</div><div class="line">  	<span class="comment">//创建用于请求的服务对象service</span></div><div class="line">      <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = Executors.newFixedThreadPool(<span class="number">3</span>, <span class="keyword">new</span> Utils.PicassoThreadFactory());</div><div class="line">      &#125;</div><div class="line">	<span class="comment">//缓存状态对象stats</span></div><div class="line">      Stats stats = <span class="keyword">new</span> Stats(memoryCache);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, loader, service, memoryCache, stats);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从几个属性的名字里可以看出来，<strong><em>Picasso</em></strong>对象中有几个很重要的属性<strong><em>loader</em></strong>、<strong><em>memory</em></strong>、<strong><em>service</em></strong>和<strong><em>stats</em></strong>。其他先放一边，首先从这个<strong><em>loader</em></strong>对象入手，来分析整个加载流程。</p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p>创建完了<strong><em>Picasso</em></strong>对象之后一般我们一定会调用的代码会是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Picasso.with(context)</div><div class="line">  .load(url)</div><div class="line">  .into(imageview);</div></pre></td></tr></table></figure>
<p>我们可以推测到代码中的后两行做的事情就是将获取资源，然后将其加载进<strong><em>ImageView</em></strong>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RequestBuilder <span class="title">load</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">	<span class="comment">//···省略代码···</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder(<span class="keyword">this</span>, path, Type.STREAM);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong><em>load()</em></strong>方法实际上所做的也就是创建一个<strong><em>RequestBuilder</em></strong>对象，并返回这个对象，<strong><em>into()</em></strong>方法也是这个类里的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">RequestBuilder(Picasso picasso, String path, Request.Type type) &#123;</div><div class="line">    <span class="keyword">this</span>.picasso = picasso;</div><div class="line">    <span class="keyword">this</span>.path = path;</div><div class="line">    <span class="keyword">this</span>.resourceId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target)</span> </span>&#123;</div><div class="line">  <span class="comment">//创建图片缓存索引key</span></div><div class="line">    String requestKey = createKey(path, resourceId, options, transformations);</div><div class="line">  <span class="comment">//根据key从缓存中查询Bitmap对象</span></div><div class="line">    Bitmap bitmap = picasso.quickMemoryCacheCheck(target, requestKey);</div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">  	<span class="comment">//如果存在已经存在于缓存中的Bitmap对象，则加载进ImageView中</span></div><div class="line">      PicassoDrawable.setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.debugging);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//设置占位图</span></div><div class="line">    <span class="keyword">if</span> (placeholderResId != <span class="number">0</span> || placeholderDrawable != <span class="keyword">null</span>) &#123;</div><div class="line">      PicassoDrawable.setPlaceholder(target, picasso.context, placeholderResId, placeholderDrawable,</div><div class="line">          picasso.debugging);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//创建图片资源请求对象传入Picasso对象的submit方法中</span></div><div class="line">    Request request =</div><div class="line">        <span class="keyword">new</span> Request(picasso, path, resourceId, target, options, transformations, type, skipCache,</div><div class="line">            noFade, errorResId, errorDrawable);</div><div class="line">    picasso.submit(request);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里贴出了<strong><em>RequestBuilder</em></strong>的构造方法和<strong><em>into()</em></strong>方法，如果缓存中有图片资源，则直接取出加载，如果没有则新建一个<strong><em>Request</em></strong>（实际上是一个<strong><em>Runnable</em></strong>）对象，并通过调用<strong><em>submit()</em></strong>方法来加载图片。接下来我么看看<strong><em>submit()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    Object target = request.getTarget();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    cancelExistingRequest(target, request.path);</div><div class="line">  <span class="comment">//将ImageView对象和Request对象以键值对的形式存入一个Map对象中</span></div><div class="line">    targetsToRequests.put(target, request);</div><div class="line">  <span class="comment">//调用Executor对象的submit()方法继续加载过程</span></div><div class="line">    request.future = service.submit(request);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里我们发现又调用了一个实例<strong><em>service</em></strong>的<strong><em>submit()</em></strong>方法，这个<strong><em>service</em></strong>实际上是一个<strong><em>Executor</em></strong>对象，这个对象也就是我们上面创建<strong><em>Builder</em></strong>的过程中构造的。我们知道<strong><em>Executor</em></strong>是<strong><em>java.util.concurrent</em></strong>类库中的一个类，这里开启了一个线程池用来处理图片请求的线程，由此我们知道这里实际上调用的就是<strong><em>Request</em></strong>的<strong><em>run()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//···省略代码···</span></div><div class="line"></div><div class="line">      picasso.run(<span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable e) &#123;</div><div class="line">      <span class="comment">//···省略代码···</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//···省略代码···</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>点进去之后，我们发现这里又接着调用了<strong><em>Picasso</em></strong>的<strong><em>run()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Bitmap result = resolveRequest(request);</div><div class="line"></div><div class="line">      request.result = result;</div><div class="line">      handler.sendMessage(handler.obtainMessage(REQUEST_COMPLETE, request));</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>到了这里我们终于发现实际上请求<strong><em>Bitmap</em></strong>资源的方法是<strong><em>resolveRequest()</em></strong>方法，并且在成功获取到了资源之后发送了一个请求成功的<strong><em>Message</em></strong>，请求成功后的部分稍后再看，这里先看看<strong><em>resolveRequest()</em></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Bitmap <span class="title">resolveRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">//检查缓存中是否存有Bitmap资源对象</span></div><div class="line">    Bitmap bitmap = loadFromCache(request);</div><div class="line">    <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">      stats.cacheMiss();</div><div class="line">      <span class="comment">//如果没有则继续请求</span></div><div class="line">      bitmap = loadFromType(request);</div><div class="line">      </div><div class="line">      <span class="comment">//将请求到的资源存入缓存中</span></div><div class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span> &amp;&amp; !request.skipCache) &#123;</div><div class="line">        cache.set(request.key, bitmap);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      stats.cacheHit();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bitmap;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>接着<strong><em>Bitmap</em></strong>方法还要经过<strong><em>loadFromType()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">loadFromType</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    PicassoBitmapOptions options = request.options;</div><div class="line">    Bitmap result = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//根据资源类型的不同采取不同的请求方法</span></div><div class="line">    <span class="keyword">switch</span> (request.type) &#123;</div><div class="line">      <span class="keyword">case</span> CONTENT:</div><div class="line">        Uri path = Uri.parse(request.path);</div><div class="line">        result = decodeContentStream(path, options);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> RESOURCE:</div><div class="line">        Resources resources = context.getResources();</div><div class="line">        result = decodeResource(resources, request.resourceId, options);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> FILE:</div><div class="line">        result = decodeFile(request.path, options);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> STREAM:</div><div class="line">        Response response = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          response = loader.load(request.path, request.retryCount == <span class="number">0</span>);</div><div class="line">          </div><div class="line">          result = decodeStream(response.stream, options);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          response.stream.close();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Unknown request type: "</span> + request.type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个方法的内容稍多，我也删去了部分，这里实际上是根据请求的资源类型的不同分别采取不同的方法去请求Bitmap资源，其中前三种不复杂，重头戏是最后一种——网络请求资源，也可以说是使用最为频繁的请求姿势。而这里的请求过程用到了我们在最开始所提到的<strong><em>Loader</em></strong>并调用了其中的<strong><em>loader()</em></strong>方法。<strong><em>Loader</em></strong>实际上是一个接口，<strong><em>loader</em></strong>的实际类型是由<strong><em>Builder</em></strong>创建的<code>loader = Utils.createDefaultLoader(context);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Loader <span class="title">createDefaultLoader</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class.forName(<span class="string">"com.squareup.okhttp.OkHttpClient"</span>);</div><div class="line">      <span class="keyword">return</span> OkHttpLoaderCreator.create(context);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> UrlConnectionLoader(context);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>从名字上可以看出这里使用了另一个Square大名鼎鼎的开源库<strong><em>OkHttp</em></strong>来处理网络请求。而这里的<strong><em>create()</em></strong>方法则创建了一个<strong><em>OkHttpLoader</em></strong>对象，我们来看看它的<strong><em>loader()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">load</span><span class="params">(String url, <span class="keyword">boolean</span> localCacheOnly)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    HttpURLConnection connection = client.open(<span class="keyword">new</span> URL(url));</div><div class="line">    connection.setUseCaches(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">if</span> (localCacheOnly) &#123;</div><div class="line">      connection.setRequestProperty(<span class="string">"Cache-Control"</span>, <span class="string">"only-if-cached"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> fromCache = parseResponseSourceHeader(connection.getHeaderField(RESPONSE_SOURCE));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(connection.getInputStream(), fromCache);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>到这里总算是完成了全部的资源请求流程。这里回到上面提到过的请求成功之后会发送一个请求成功的消息。然后我们看看对于这个消息是在哪里接受并且如何处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      Request request = (Request) msg.obj;</div><div class="line">      <span class="keyword">if</span> (request.future.isCancelled() || request.retryCancelled) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Picasso picasso = request.picasso;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> REQUEST_COMPLETE:</div><div class="line">          picasso.targetsToRequests.remove(request.getTarget());</div><div class="line">          request.complete();</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> REQUEST_RETRY:</div><div class="line">          picasso.retry(request);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> REQUEST_DECODE_FAILED:</div><div class="line">          picasso.targetsToRequests.remove(request.getTarget());</div><div class="line">          request.error();</div><div class="line">          <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Unknown handler message received: "</span> + msg.what);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>原来在<strong><em>Picasso</em></strong>类中，一开始就创建了一个<strong><em>Handler</em></strong>来处理各种请求状态，这个<strong><em>Handler</em></strong>被创建在主线程。在这里，对于请求成功的情况，调用了<strong><em>Request</em></strong>类的<strong><em>complete()</em></strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span> </span>&#123;</div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">      Context context = picasso.context;</div><div class="line">      <span class="keyword">boolean</span> debugging = picasso.debugging;</div><div class="line">      PicassoDrawable.setBitmap(target, context, result, loadedFrom, noFade, debugging);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里涉及到了一个工具类<strong><em>PicassoDrawable</em></strong>，调用其中的<strong><em>setBitmap</em></strong>方法来加载图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBitmap</span><span class="params">(ImageView target, Context context, Bitmap bitmap, LoadedFrom loadedFrom,</span></span></div><div class="line">      <span class="keyword">boolean</span> noFade, <span class="keyword">boolean</span> debugging) &#123;</div><div class="line">    PicassoDrawable picassoDrawable = extractPicassoDrawable(target);</div><div class="line">    <span class="keyword">if</span> (picassoDrawable != <span class="keyword">null</span>) &#123;</div><div class="line">      picassoDrawable.setBitmap(bitmap, loadedFrom, noFade);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      target.setImageDrawable(<span class="keyword">new</span> PicassoDrawable(context, bitmap, loadedFrom, noFade, debugging));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>到这里算是彻底地完成了整个请求加载到流程。后面我还会去分析这个库的其他部分，所以说。。。。。。我就先去歇一会啦！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;img src=&quot;/2016/10/18/Picasso源码学习（一）/picasso_cover.png&quot; alt=&quot;picasso_cover.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;从这里开始我会开始阅读一款来自于Square的大名鼎鼎的图
    
    </summary>
    
      <category term="拆轮子系列" scheme="http://yoursite.com/categories/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Picasso" scheme="http://yoursite.com/tags/Picasso/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>一个新的开始</title>
    <link href="http://yoursite.com/2016/09/28/%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2016/09/28/一个新的开始/</id>
    <published>2016-09-27T16:00:00.000Z</published>
    <updated>2017-02-06T15:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>从开始学习Android到现在不知不觉有一年出头了，作为学生也总算是到了大三了。但是，一名coder现在才想起来开个自己的博客好像也是稍微有点迟啊（滑稽脸）。虽然不知道未来在这博客里能写多少有意思的东西，但是既然已经开了，那就把它作为一个标志，象征一个新的学习阶段的开始吧。</p>
<!--excerpt-->
<h2 id="好像并没有学多少东西啊"><a href="#好像并没有学多少东西啊" class="headerlink" title="好像并没有学多少东西啊"></a>好像并没有学多少东西啊</h2><p>我自己是做Android的，不过现在想想貌似会的也就是Android上的东西。从大一开始接触Java，那么吊儿郎当地学了那么久，不敢说自己会多少东西，但至少装装样子还是可以的。</p>
<p>其实说到底我所学的东西也就是“Java——Android”这样简单的两点一线，再往细的说其实也就仅限于Android应用的开发。虽然曾经也看了一些Android的源码，想要深入地去学学，但是现在仔细想想，真的是一点都记不起来了（这应该也是开博客的原因吧）。</p>
<p>想到这里不禁感慨要学的东西还有好多，再加上明年就要不得不去面对实习的压力了，觉得貌似将会度过大学期间最为充（麻）实（烦）的一年了。所以就像上面写的一样，从这篇博客开始也得稍微振作一下，把我这个懒家伙所有能拿出来的精力给好好释放一下了。</p>
<h2 id="一些小小的计划"><a href="#一些小小的计划" class="headerlink" title="一些小小的计划"></a>一些小小的计划</h2><p>现在正在写一个<a href="https://github.com/zpauly/GitHub_Android" target="_blank" rel="external">Github的客户端</a>，这应该是我第一个完整的正式的项目了，所以我首先的期望就是能够把这个项目完完整整的坚持下来，虽然一个人写还是挺累的，但是想到写完之后的效果，另外说不定还能上线，还有点小激动呢。</p>
<p>写项目刚开始的时候还是感觉自己挺得心应手，但是随着代码量逐渐多了起来，程序的模块逐渐复杂了起来，重构以前写的模块已经成了家常便饭，想想真心觉得自己对工程项目的处理水平还真是有限。为了对自己的这方面有所提高，首当其冲的就是设计模式的学习了。虽然设计模式以前也有所学习，但是似乎也仅限于理论水平，于是这次决定把这东西再重新拾起来，并把它运用起来。除了重学设计模式这个想法外，看看别人写的项目也是必不可少的，github上的大神那么多，取取经自然是理所当然的啦。</p>
<p>另外就是决定好好拆一拆轮子。上面也提到我其实对Android的学习也仅仅一直都是应用层这一面，况且自我感觉学的还不深，所以拆一拆自然也就很有必要了。对于拆轮子这种事，肯定还是得挑那些超级有名的轮子来拆比较好。我的想法是首先从Picasso这个图片加载库开始，然后就是OkHttp、EventBus、RxJava……（真是又多又难啊，不知道我什么时候才能看完）还有一个方面就是Android源码的学习。对于这个，市面上这么多不错的书，配合着去看源码，本人还是有些自信的。</p>
<p>最后，我还有的一个想法就是能够多点一些技能树，毕竟只会这么一个方面的内容终归还是不够的。第一个想点点技能树就是C++了。虽然100个不愿意，但是学到现在再也绕不过C++终归是个不争点事实，不管是要学NDK开发还是以后其他的内容C++就在眼前，只能面对面硬杠了。另外就是自己也有那么一点想学Python的意思，这个倒不是什么必须的，就是觉得挺有意思，就当本职外的兴趣在休闲的时候学学吧。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>往上一看，虽然写的短，但是要干的事情真是多啊，不多说了，要去学习了。。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;从开始学习Android到现在不知不觉有一年出头了，作为学生也总算是到了大三了。但是，一名coder现在才想起来开个自己的博客好像也是稍微有点迟啊（滑稽脸）。虽然不知道未来在这博客里能写多少有意思的东西，但是既然已经开了，那就把它作为一个
    
    </summary>
    
      <category term="随手写写" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
